# Лабораторная работа 2: Pipeline

## Концепты
- Абстракция (ссылка на код по имени)
- Полиморфизм (интерфейс)
- Контекст
- Паттерн Адаптер
- Паттерн Strategy (передача действия параметром)
- Интроспекция
- Data-Oriented (манипуляция операций как с данными)
- Паттерн Декоратор (Wrapper)

## Описание

Данный проект представляет собой гибкий и расширяемый фреймворк для построения конвейеров обработки данных (пайплайнов) на языке Python. Фреймворк демонстрирует практическое применение нескольких паттернов проектирования в контексте построения модульных и поддерживаемых систем обработки данных.

Основная идея заключается в создании последовательности шагов (steps), каждый из которых выполняет определенную операцию над общим контекстом (Context). Это позволяет разбить сложный процесс обработки на независимые, тестируемые компоненты.

## Архитектура и паттерны проектирования

### 1. Context (Контекст)
Класс `Context` служит контейнером для передачи данных между шагами пайплайна. Это обертка над словарем с методами для удобного доступа к данным.

### 2. PipelineStep (Протокол шага)
Протокол `PipelineStep` определяет интерфейс, который должны реализовывать все шаги пайплайна:
- `execute(context: Context) -> None` - выполняет операцию, модифицируя контекст
- `describe(builder: io.StringIO) -> None` - предоставляет текстовое описание шага для интроспекции

### 3. Реализации шагов (паттерны проектирования)

#### Strategy (Стратегия) - `FuncStep`
Инкапсулирует произвольную функцию как объект шага, позволяя легко подменять алгоритмы выполнения.

#### Adapter (Адаптер) - `LegacyAdapter`
Адаптирует legacy-функции со старыми сигнатурами к интерфейсу `PipelineStep`, обеспечивая совместимость со старым кодом.

#### Decorator (Декоратор) - `BeforeAfterDecorator`
Добавляет поведение до и после выполнения оборачиваемого шага, что полезно для логирования, измерения времени, валидации.

#### Composite (Компоновщик) - `NestedPipelineStep`
Позволяет встраивать целые пайплайны как отдельные шаги, обеспечивая иерархическую структуру.

#### Singleton (Одиночка) - `SingletonStep`
Реализация через метакласс `SingletonMeta` для шагов без состояния, которые можно переиспользовать.

### 4. Pipeline (Управление пайплайном)
Класс `Pipeline` управляет последовательностью шагов, предоставляя методы для добавления, вставки и удаления шагов, а также для выполнения всей цепочки.

### 5. Интроспекция
Функции `pipeline_to_string()` и `print_pipeline()` позволяют получать текстовое представление структуры пайплайна, что упрощает отладку и документирование.

## Пример использования

```python
# Создание контекста с исходными данными
ctx = Context({'src': "Пример текста для обработки"})

# Создание пайплайна
pipeline = Pipeline()

# Добавление шагов обработки текста
pipeline.add_step(FuncStep("Загрузка", load_text_action))
pipeline.add_step(FuncStep("Нормализация", normalize_action))
pipeline.add_step(FuncStep("Токенизация", tokenize_action))

# Добавление адаптера для legacy-кода
pipeline.add_step(LegacyAdapter("Увеличение регистра", legacy_uppercase))

# Добавление декоратора с логированием
decorated_step = BeforeAfterDecorator(
    FuncStep("Фильтрация", filter_stopwords_action),
    before=lambda ctx: print("Начало фильтрации"),
    after=lambda ctx: print("Конец фильтрации")
)
pipeline.add_step(decorated_step)

# Выполнение пайплайна
pipeline.execute(ctx)

# Получение результата
result = ctx.get('result')
```

## Запуск демонстрации и тестов

Для запуска демонстрационного примера выполните:
```bash
python pipeline.py
```

Демонстрация включает:
1. Создание сложного пайплайна с использованием всех паттернов
2. Вывод структуры пайплайна через интроспекцию
3. Выполнение обработки текста
4. Запуск юнит-тестов

Тесты проверяют:
- Корректность обработки текста
- Работу синглтона
- Корректность адаптера для legacy-функций

## Преимущества подхода

1. **Модульность** - каждый шаг независим и может быть легко заменен
2. **Тестируемость** - шаги можно тестировать изолированно
3. **Расширяемость** - легко добавлять новые типы шагов через наследование
4. **Поддержка legacy-кода** - адаптеры позволяют интегрировать старый код
5. **Интроспекция** - возможность анализировать структуру пайплайна
6. **Гибкая конфигурация** - шаги можно динамически добавлять, удалять, переставлять

## Возможные улучшения

1. Добавление обработки ошибок и механизма повтора шагов
2. Поддержка асинхронного выполнения шагов
3. Визуализация пайплайна в виде графа
4. Сериализация/десериализация конфигурации пайплайна
5. Параллельное выполнение независимых шагов

## Вывод

Данный pipeline демонстрирует, как комбинация паттернов проектирования позволяет создавать гибкие, поддерживаемые и расширяемые системы обработки данных. Реализация поддерживает принципы SOLID, особенно принцип единственной ответственности и открытости/закрытости.

Код может служить основой для построения сложных ETL-процессов, конвейеров обработки данных, workflow-систем и других приложений, где требуется модульная обработка данных с возможностью легкой реконфигурации.